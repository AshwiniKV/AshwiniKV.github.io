any(adjacency[,1]%in%junc.i & adjacency[,2]%in%junc.j) | any(adjacency[,1]%in%junc.j & adjacency[,2]%in%junc.i)
}
closedness <- function(cluster) {
neighbours <- c(adjacency[adjacency[,1]%in%cluster,2],adjacency[adjacency[,2]%in%cluster,1])
result <- mean(neighbours%in%cluster)
#  attr(result,"neighbours") <- length(neighbours)
result
}
shape.penalty <- function(i, j, clustering) {
clust1 <- which(clustering==i)
clust2 <- which(clustering==j)
-closedness(c(clust1,clust2))+.5*closedness(clust1)+.5*closedness(clust2)
}
junction.link<-function(adjacency, clustering)
{
history <- list(clustering)
counter <- max(clustering)
position <- character(length(clustering))
cumulative.badness <- 0
while (length(unique(clustering))>1) {
clusters <- unique(clustering)
newcdf<-cdf.junction
best.badness <- Inf
best.idx <- NULL
for (i in 1:(length(clusters)-1))
for (j in (i+1):length(clusters)) {
clust.i <- clusters[i]
clust.j <- clusters[j]
if (merge.allowed(clust.i, clust.j, clustering, adjacency)) {
clusters.new <- clustering
clusters.new[clusters.new%in%c(clust.i, clust.j)] <- max(clusters.new)+1
attributes(clusters.new) <- NULL
current.badness <- compute.badness(clust.i, clust.j, newcdf) + 1.5*
shape.penalty(clust.i, clust.j, clustering)
cat(paste(clust.i,"+",clust.j,"=",current.badness,"\n"))
attr(current.badness, "clusters.new") <- clusters.new
if (!is.nan(current.badness) && ((current.badness < best.badness-1e-8) ||
((current.badness < best.badness+1e-8) && (runif(1)<0.5)))) {
#Keep least worst merge
best.idx <- c(clust.i, clust.j)
best.badness <- current.badness
}
}
}
counter <- counter + 1
cat(".")
select <- clustering==best.idx[1]
if (is.null(best.idx) || mean(which(clustering==best.idx[1]))<=mean(which(clustering==best.idx[2]))) {
c1 <- "l"
c2 <- "r"
} else {
c1 <- "r"
c2 <- "l"
}
position[select] <- paste0(c1,position[select])
select <- clustering==best.idx[2]
position[select] <- paste0(c2,position[select])
clustering[clustering%in%best.idx] <- counter
cdf.junction[[counter]]<-(cdf.junction[[best.idx[1]]]+ cdf.junction[[best.idx[2]]])/2
cumulative.badness <- cumulative.badness + best.badness
attr(clustering,"badness") <- cumulative.badness
history[[length(history)+1]] <- clustering
if (is.null(best.idx)) break
}
attr(history, "position") <- position
history
}
########################################################################
jl<-junction.link(adjacency, clustering)
junctions<-1:36
cl<-jl[[34]]
##########################################################################
id <- apply(outer(cl,unique(cl),"=="),1,which)
plot(coords$x, coords$y, cex = 2, col = id)
text(coords$x, coords$y, id)
par(mfrow = c(1,2))
plot(coords$x, coords$y, pch = 19, cex = 2, col = coords$index, main = "Simulated data")
id <- apply(outer(cl,unique(cl),"=="),1,which)
new.cluster<-rep(NA, nrow(adjacency))
for(i in 1:length(junctions)){
idx<-which(adjacency[,1] == junctions[i])
new.cluster[idx]<-id[i]
}
#clusters<-as.numeric(occ.data[7, -1])
library(MASS)
#par(mar=rep(0.1,4))
palette <- rev(colorRampPalette(c("blue","red","yellow","green"))(100))
ids<-c(20, 45, 70, 90)
colors<-palette[ids]
new.colors<-rep(NA, length(id))
for(i in unique(id)){
idx<-which(i == id)
new.colors[idx]<-colors[i]
}
eqscplot(coords$x, coords$y, pch = 16, cex = 3, col = new.colors, xaxt = "n", yaxt = "n", xlab = " ",bty = "n", ylab = " ", main = "Clustered data")
for (i in 1:nrow(adjacency)) {
idx.1<-adjacency[which(as.numeric(adjacency[i,1]) == adjacency[,1]),1]
idx.2<-adjacency[which(as.numeric(adjacency[i,1]) == adjacency[,1]), 2]
arrows(coords$x[idx.1], coords$y[idx.1], coords$x[idx.2], coords$y[idx.2], lwd = 2,length=  0.2, col = new.colors[idx.1])
}
#text(origin.idx, origin.idy, nodes.1)
n.clust <- length(unique(new.cluster))
times <- seq(0, 216, len=100)
# Occupancies - Sequence
occupancies <- seq(0, 100, len=100)
outputs <- array(dim=c(length(occupancies), length(times), n.clust))
for (clustid in 1:n.clust) {
clust <- which(new.cluster==clustid)
# Assign zero values to output matrix with dim 100 by 240
output <- matrix(0, ncol=length(times), nrow=length(occupancies))
# Incoming links
links <- adjacency[clust, 1]
# Occupancy matrix - incoming links
cur.dat <- as.numeric(as.matrix(dataset[, clust]))
for (i in 1:length(times)) {
time <- times[i]
# Weight using unique records for time.
# Calculate the density using the time as mean and 0.25 as standard deviation
weights <- rep(dnorm(times, mean = time, sd = 1000),length(links))
# Standardise Weights = weights /sum(weights)
weights <- weights/sum(weights)
# Gaussian Density Kernel with above weights. Bandwidth = 5
# Number of equally spaced points is 100
# 0 to 100 - left and right-most points of the grid.
output[,i] <- density(cur.dat, weights=weights, bw=15, from=0, to=100, n=100)$y
}
#Specifying the values of an array - by the cluster
outputs[,,clustid] <- output
}
# Number of columns and rows for the plotting window
ncol <- ceiling(sqrt(n.clust+1))
nrow <- ceiling((n.clust+1)/ncol)
#ncol<-2
#nrow<-3
par(mfrow = c(ncol, nrow), oma = c(5,4,0,0) + 0.1, mar = c(1,1,2,2) + 0.1)
par(mfrow = c(2,2))
threedplot <- function(times, occupancies, density, subset=round(seq(1,length(times),len=9)), theta=120, phi=30, zmax=1, ...) {
M <- persp(times,occupancies, matrix(NA, nrow=length(times), ncol=length(occupancies)),zlim=c(0,zmax),
xlab="time", ylab="occupancy", zlab="frequency", ticktype = "detailed",axes = TRUE, theta=theta, cex.lab = 1.4, cex.axis = 1.4,phi=phi)
for (idx in subset)
polygon(trans3d(times[idx],c(occupancies,occupancies[length(occupancies)],occupancies[1]),c(density[idx,],0,0),M), ...)
}
library(colorRamps)
#n.clust<-c(2, 4,6,8,9)
for (clustid in 1:n.clust) { # n.clust) {
#colour <- rainbow(n.clust)[clustid]
#colour <- col2rgb(colour)/255
#colour <- rgb(colour[1,], colour[2,], colour[3,], 0.75)
threedplot(times/3600, occupancies, t(outputs[,,clustid]), zmax=max(outputs), col= new.colors[which(id==clustid)])
title(paste0("Cluster ",clustid), cex.main = 1.35)
}
jl<-junction.link(adjacency, clustering)
junctions<-1:36
cl<-jl[[34]]
cl
eqscplot(coords$x, coords$y, pch = 16, cex = 3, col = new.colors, xaxt = "n", yaxt = "n", xlab = " ",bty = "n", ylab = " ", main = "Clustered data")
plot(coords$x, coords$y, pch = 19, cex = 2, col = new.colors, main = "Simulated data")
for (i in 1:nrow(adjacency)) {
idx.1<-adjacency[which(as.numeric(adjacency[i,1]) == adjacency[,1]),1]
idx.2<-adjacency[which(as.numeric(adjacency[i,1]) == adjacency[,1]), 2]
arrows(coords$x[idx.1], coords$y[idx.1], coords$x[idx.2], coords$y[idx.2], lwd = 2,length=  0.2, col = new.colors[idx.1])
}
plot(coords$x, coords$y, pch = 19, cex = 2, col = new.colors, main = "Simulated data")
eqscplot(coords$x, coords$y, pch = 16, cex = 3, col = new.colors, xaxt = "n", yaxt = "n", xlab = " ",bty = "n", ylab = " ", main = "Clustered data")
for (i in 1:nrow(adjacency)) {
idx.1<-adjacency[which(as.numeric(adjacency[i,1]) == adjacency[,1]),1]
idx.2<-adjacency[which(as.numeric(adjacency[i,1]) == adjacency[,1]), 2]
arrows(coords$x[idx.1], coords$y[idx.1], coords$x[idx.2], coords$y[idx.2], lwd = 2,length=  0.2, col = new.colors[idx.1])
}
install.packages(c("abind", "colorspace", "digest", "evaluate", "formatR", "Formula", "gdata", "geosphere", "ggplot2", "haven", "htmltools", "htmlwidgets", "httpuv", "igraph", "irlba", "jsonlite", "knitr", "leaflet", "mapproj", "maps", "markdown", "mime", "partykit", "plyr", "proto", "quantmod", "R6", "RandomFields", "RandomFieldsUtils", "raster", "Rcpp", "reshape2", "RgoogleMaps", "rlang", "rmarkdown", "scales", "shape", "shiny", "sp", "splancs", "stringi", "stringr", "tibble", "TTR", "visNetwork", "webshot", "xts", "yaml", "zoo"))
install.packages("rmarkdown")
library(rmarkdown)
library(partykt)
library(partykit)
install.packages("partykit")
library(partykit)
#gets node ID for all the left splits
ptree_left <- function(newtree, start_id){
node<-as.list(node_party(newtree))
if (!is.null(node[[start_id]]$kids)){node[[start_id]]$kids[1]}
}
#gets node ID for all the right splits
ptree_right <- function(newtree, start_id){
node<-as.list(node_party(newtree))
if (!is.null(node[[start_id]]$kids)){node[[start_id]]$kids[2]}
}
# get prediction for the relevant  node
ptree_y <- function(newtree, node_id)
{
# Picks out the prediction from the ctree structure
p<-predict_party(newtree, node_id)[[1]]
return(p)
}
ptree_criteria <- function(newtree, node_id, left)
{
tree<-node_party(newtree)
node<-as.list(node_party(newtree))
if (length(nodeapply(tree, ids = nodeids(tree))[[node_id]]) == "0") # Check if this is a terminal node
{
return("(error: terminal node)");
}
if (node[[node_id]]$split$breaks){
sp <- node[[node_id]]$split$breaks
if(rpart.party == TRUE){
split_id<-node[[node_id]]$split$varid
vn<-names(data_party(newtree))[split_id]
}else{
vn <- names(node[[node_id]]$info$p.value)}
# Left being true then the left string of variables with split points are returned
if (left) {
op <- '<='
} else {
op <- '>'
}
return(paste(vn, op, sp))
} else {
if (left){
l <- is.null(node[[node_id]]$split$breaks)
} else {
l <-  is.null(!node[[node_id]]$split$breaks)
}
r <- paste(attr(node[[node_id]]$split$breaks, 'levels')[l], sep='', collapse="','")
return(paste(names(node[[node_id]]$info$p.value), " in ('", r,"')", sep=''))
}
}
l_node <- function(newtree, node_id = 1, start_criteria = character(0))
{
tree<-node_party(newtree)
node<-as.list(node_party(newtree))
if (!length(nodeapply(tree, ids = nodeids(tree))[[node_id]])) {
prediction <- predict_party(newtree, node_id)[[1]]
ypred <- paste(start_criteria,',y =',prediction)
print(ypred)
}
left_node_id <- ptree_left(newtree, node_id)
right_node_id <- ptree_right(newtree,node_id)
if (is.null(left_node_id) != is.null(right_node_id)) {
print('left node ID != right node id')
}
ypred <- character(0)
if (!is.null(left_node_id)) {
new_criteria <- paste(start_criteria, ptree_criteria(newtree, node_id, T), sep=',')
if (1 == node_id)
new_criteria <- ptree_criteria(newtree, node_id, T)
ypred <- l_node(newtree, left_node_id, new_criteria)
}
if (!is.null(right_node_id)) {
new_criteria <- paste(start_criteria, ptree_criteria(newtree, node_id, F), sep=',')
if (1 == node_id)
new_criteria <- ptree_criteria(newtree, node_id, F)
ypred <- paste(ypred, l_node(newtree, right_node_id, new_criteria))
}
if(!is.character(ypred)){
return(ypred)
}
}
list_node<-function(treet){
pathway<-capture.output(l_node(treet))
gerid<-gsub("*\\[1](*)\\'*", "\\1", pathway)
gerid<-gsub("\"", "", gerid)
return(paste(gerid, collapse = " ;"))
}
## Function to get rid of spaces in strings
trim <-function (x){
gsub("^\\s+|\\s+$", "", x)}
makeTransparent = function(..., alpha=0.5) {
## Helper function to make colors transparent
if(alpha<0 | alpha>1) stop("alpha must be between 0 and 1")
alpha = floor(255*alpha)
newColor = col2rgb(col=unlist(list(...)), alpha=FALSE)
.makeTransparent = function(col, alpha) {
rgb(red=col[1], green=col[2], blue=col[3], alpha=alpha, maxColorValue=255)
}
newColor = apply(newColor, 2, .makeTransparent, alpha=alpha)
return(newColor)
}
minmax.mat <- function(str,varnms, interval) {
## Helper function to create a matrix of ranges for each variable in a path to a node
comps <- strsplit(str,",")
MMM <- matrix(data=rep(c(-Inf,Inf, " "),length(varnms)),nrow=length(varnms),ncol=3,byrow=TRUE) ### min-max matrix
rownames(MMM) <- varnms
#nodeids(potentialtree)
Mlist<-list()
#Y<-fitted(cond.tree)[[3]]
if(is.numeric(Y)){length.mat<-length(comps[[1]])-2}
if(is.factor(Y)){if(interval == TRUE){length.mat<-length(comps[[1]])-3}else{length.mat<-length(comps[[1]])-2}}
for(i in 1:length.mat) {
nodestr <- strsplit(trim(comps[[1]][i])," ")
node.varnm <- trim(nodestr[[1]][1])
node.dir <- trim(nodestr[[1]][2])
node.split <- trim(nodestr[[1]][3])
var.row <- which(varnms==node.varnm)
if(node.dir == "<=") {
MMM[var.row,2] <- as.numeric(node.split)
MMM[var.row,3] <- "<="
} else {
MMM[var.row,1] <- as.numeric(node.split)
MMM[var.row,3] <- ">"
}
Mlist[[i]]<-c(node.varnm, MMM[var.row,])
output <- matrix(unlist(Mlist), ncol = 4, byrow = TRUE)
}
if(is.factor(Y)){y<-paste0(comps[[1]][length(comps[[1]]) - 2],",",comps[[1]][length(comps[[1]]) - 1])}
if(is.numeric(Y)){y <- comps[[1]][length(comps[[1]]) - 1]}
return(list(M=MMM,y=y))
}
#Terminal nodes
#which(!nodeids(cond.tree1)%in%nodeids(cond.tree1, termina = TRUE))
plot.minmax <- function(My,X,Y, str) {
## Main function which plots the bars for each variable along with a histogram of the outcome
comps <- strsplit(str,",")
mymat <- matrix(as.numeric(My$M[,-3]), ncol = 2)
my.y <- My$y
mydir<-My$M[,3]
if(!is.factor(Y)) {
my.y.val <- as.numeric(strsplit(trim(my.y)," ")[[1]][3])
my.y.pct <- ecdf(Y)(my.y.val)
}
var.nms <- rownames(My$M)
act.vars <- apply(mymat,1,function(x) { !all(abs(x)==Inf) })
max.y <- sum(act.vars)+1
rbw <- rainbow(n=nrow(mymat))
## Find the y's which "belong" in this node
node.index <- 1:length(Y)
for(i in 1:nrow(mymat)) {
digit<-8
node.index <- intersect(node.index,c(which(round(X[,i],digit)>round(mymat[i,1],digit)&round(X[,i],digit)<=round(mymat[i,2],digit))))
}
## Create the underlying histogram, but don't plot it yet
if(is.factor(Y)) {
wdth <- 1/length(levels(Y))
H <- hist(as.integer(Y[node.index])/length(levels(Y)),breaks=seq(0,1,length.out=length(levels(Y))+1),plot=FALSE)
## Scale the histogram so it fits vertically on the plot.
scale.factor <- max.y/max(H$density)
## Set up an empty plot of the correct size
plot(NA,xlim=c(0,1),ylim=c(0,max.y),ylab="",xlab="Percentile",font = 2, main=paste0("Node ID = ",tail(comps[[1]], 1),"(", "n = ",length(node.index),")"),bty="n",yaxt="n", cex.axis = 1.5,cex.main = 2.25)
## Plot the background histogram
barplot(scale.factor*H$density,width=wdth,col=rgb(0,0,0,0.15),border=rgb(0,0,0,0.1),add=TRUE,space=0,yaxt="n")
## Add the category labels
text(seq(wdth/2,1-wdth/2,by=wdth),rep(0,length(levels(Y))),levels(Y),pos=3,adj=0.5,cex=1.5, col=gray(0.1))
#text(seq(wdth/2,1-wdth/2,by=wdth),rep(quantile(scale.factor*H$density, 0.97),length(levels(Y))),levels(Y),pos=3,adj=0.5,cex=1.5,col=gray(0.5))
}
else{
H <- hist(ecdf(Y)(Y[node.index]),breaks=seq(0,1,by=0.1),plot=FALSE)
## Scale the histogram so it fits vertically on the plot.
scale.factor <- max.y/max(H$density)
## Set up an empty plot of the correct size
plot(NA,xlim=c(0,1),ylim=c(0,max.y),ylab="", xlab="Percentile",font = 2,main=paste0("Node ID = ", tail(comps[[1]], 1), " (Mean = ",round(my.y.val, 2),", n = ",length(node.index),")"),bty="n", yaxt = "n", cex.axis = 1.5, cex.main =2.25)
## Plot the background histogram
bp<-barplot(scale.factor*H$density,width=0.1,col=rgb(0,0,0,0.15),border=rgb(0,0,0,0.1),add=TRUE,space=0, yaxt = "n")
counts.ecdf<-ceiling(10*ecdf(Y)(Y[node.index]))
mean.Ynode<-data.frame(counts.ecdf, Y[node.index])
mean.Y<-aggregate(Y[node.index], list(counts.ecdf),  mean)$x
if(all((mean.Y)<=10)){mean.Y<-round(mean.Y, 1)}else{
mean.Y<-round(mean.Y, 0)
}
titles.Y<-rep(" ", length(H$density))
titles.Y[!H$density == 0]<-mean.Y
text(bp, 0, titles.Y, pos=3,adj=0.5,cex=1.5)
## Draw in a line for the mean
mu.Y <- mean(Y[node.index])
segments(ecdf(Y)(mu.Y),0,ecdf(Y)(mu.Y),max.y,col=rgb(0,0,0,0.5),lwd=2)
}
## Now plot the horizontal bars corresponding to each variable.
j <- 1
for(i in which(act.vars)) {
F.x <- ecdf(X[,var.nms[i]])
lo <- ifelse(mymat[i,1]==-Inf,0,F.x(mymat[i,1]))
hi <- ifelse(mymat[i,2]==Inf,1,F.x(mymat[i,2]))
polygon(c(lo,lo,hi,hi),c(j-0.5,j+0.5,j+0.5,j-0.5),col=makeTransparent(rbw[i],0.5),border=NA)
if(rownames(My$M)[i] == "sex"){
if(mymat[i] != "-Inf"){
text(mean(c(lo,hi)),j,paste0(rownames(My$M)[i],"-", c("male", "female")[mymat[i]]), font = 2, cex = 1.6)}else{
text(mean(c(lo,hi)),j,paste0(rownames(My$M)[i],"-", "female"), font = 2, cex = 1.6)
}}
if(rownames(My$M)[i] != "sex"){
if(mymat[i,2] == Inf){idx <- 1}else{idx <-2}
if(My$M[i,1] != -Inf && My$M[i,2] == Inf){
text(mean(c(lo,hi)),j,paste0(rownames(My$M)[i], ">",round(as.numeric(My$M[i,1]), 2)), font = 2, cex = 1.6)
}
if(My$M[i,1] != -Inf && My$M[i,2] != Inf){
text(mean(c(lo,hi)),j,paste0(rownames(My$M)[i], "<=",round(as.numeric(My$M[i,2]), 2), "\n",rownames(My$M)[i], ">",round(as.numeric(My$M[i,1]), 2)), font = 2, cex = 1.6)
}
if(My$M[i,1] == -Inf && My$M[i,2] != Inf){
text(mean(c(lo,hi)),j,paste0(rownames(My$M)[i], "<=",round(as.numeric(My$M[i,2]), 2)), font = 2, cex = 1.6)
}}## Label the variables
j <- j+1
}
}
visTree <- function(cond.tree,rng=NULL, interval, rpart.party) {
## Wrapper function to produce plots from a conditional inference tree
## 'range' parameter can restrict plotting to a particular set of nodes
splittree<-list_node(cond.tree)
structure<-strsplit(splittree, split=";")
#structure<-unlist(strsplit(list_node(cond.tree), split=";"))
terminal.id<-nodeids(cond.tree, terminal = TRUE)
if(length(structure[[1]]) == length(terminal.id)){
structure[[1]]<-sapply(1:length(structure[[1]]), function(i){
paste0(structure[[1]][i],",", terminal.id[i], " ")})
}
input.info<-data_party(cond.tree)
#  X <- input.info[,2:(length(input.info)-3)]
if(rpart.party == TRUE){
X <- input.info[,2:(length(input.info)-2)]
Y <- fitted(cond.tree)[[2]]
}else{
X <- input.info[,2:(length(input.info)-3)]
Y <- fitted(cond.tree)[[3]]
}
if(is.factor(Y)) {
n.terminals <- length(structure[[1]])
#prob.mat <- matrix(data=unlist(lapply(structure[[1]],function(S) {
# unlist(lapply(strsplit(S,","),function(split.S) {
# seg <- unlist(split.S[length(split.S)])
# as.numeric(trim(strsplit(seg,"=")[[1]][2]))
#}))
#})), nrow=n.terminals)
y.list <- sapply(1:length(structure[[1]]),function(j) {
seg<-strsplit(structure[[1]],",")
if(interval == TRUE){paste0(seg[[j]][c((length(seg[[j]])-2): (length(seg[[j]])-1))], collapse = ",")}else{
paste0(seg[[j]][length(seg[[j]])-2], collapse = ",")}
})
x.list <- sapply(1:length(structure[[1]]),function(j) {
seg<-strsplit(structure[[1]],",")
x.l<-sapply(1:length(seg), function(i){
if(interval == TRUE){
x.length<-length(seg[[i]]) - 3}else{
x.length<-length(seg[[i]])-2}
})
if(interval == TRUE){
paste0(seg[[j]][1:(length(seg[[j]])-3)], collapse = ",")}else{
paste0(seg[[j]][1:(length(seg[[j]])-2)], collapse = ",")
}
})
term.node<-sapply(1:length(structure[[1]]), function(j){
seg<-strsplit(structure[[1]], ",")
if(interval == TRUE){paste0(tail(seg[[j]],1), collapse = ",")}else{
paste0(tail(seg[[j]],1), collapse = ",")}
})
structure <- lapply(1:length(y.list),function(i) {
paste0(x.list[[i]],", ",y.list[[i]], ", ", term.node[[i]])
})
}
if(length(unlist(structure))==1) { stop("Tree has only a single node; nothing to visualize.") }
#terminal.id<-nodeids(cond.tree, terminal = TRUE)
n.terminals <- ifelse(is.null(rng),length(unlist(structure)),length(rng))
if(is.null(rng)) {
index <- 1:n.terminals } else {
index <- min(rng):min(max(rng),length(unlist(structure))) } ## Should probably do some range checking
par(mfrow=c(2,ceiling(length(index)/2)),mar=c(2,1,3,1))
sapply(unlist(structure)[index],function(S) { plot.minmax(minmax.mat(S,colnames(X), interval),X,Y, S)})
}
######################Categorical###########################
library(partykit)
set.seed(120)
X1 <- rnorm(100)
X2 <- rnorm(100)
Y <- cut(rnorm(100,mean=X1+X2,sd=1),4)
X<-cbind(X1, X2)
varnms<-colnames(X)
cond.tree2 <- partykit::ctree(Y~X1+X2, control = ctree_control(mincriterion = 0.95))
plot(cond.tree2)
visTree(cond.tree2, interval = TRUE, rpart.party = FALSE)
rpart.party = FALSE
visTree(cond.tree2, interval = TRUE, rpart.party = FALSE)
visTree(cond.tree2, rng = NULL, interval = TRUE, rpart.party = FALSE)
matrix(c(3, 0, 0, -4), nrow = 2, ncol = 2)
A<-matrix(c(3, 0, 0, -4), nrow = 2, ncol = 2)
1/A
A<-matrix(c(3, 0, 0, -2), nrow = 2, ncol = 2)
A
1/A
solve(A)
A<-matrix(c(3, 0, 0, 3), nrow = 2, ncol = 2)
A
solve(A)
B<-a
B<-a
B<-A
B/3
A<-matrix(c(2, 0, 0, 2), nrow = 2, ncol = 2)
solve(A)
B<-A
B
B/2
2*solve(A)
-log10000
-log(1000)
?log
-log10(1000)
ln(1/sqrt(e))
log(1/sqrt(e))
log(1/sqrt(exp))
exp
e
log(1/sqrt(exp(1)))
setwd("C:\\Users\\user\\Documents\\GitHub\\AshwiniKV.github.io")
setwd("C:\\Users\\2158844V\\Documents\\GitHub\\AshwiniKV.github.io")
rmarkdown::render_site()
rmarkdown::render_site()
rmarkdown::render_site()
rmarkdown::render_site()
rmarkdown::render_site()
rmarkdown::render_site()
rmarkdown::render_site()
rmarkdown::render_site()
rmarkdown::render_site()
rmarkdown::render_site()
rmarkdown::render_site()
rmarkdown::render_site()
rmarkdown::render_site()
rmarkdown::render_site()
